#coding: utf-8

module Reader
  require 'kconv'
  require 'csv'
  require 'nkf'
  require 'nokogiri'
  require 'zip/zip'
  require 'shell'
  require 'tempfile'
  
  @@bilingualArray = []
  #
  #each bilingual data contains following keys
  # :filename = all
  # :source   = all
  # :target   = all
  # :id       = XLZ and CSV, TXT (Line number)
  # :note     = XLZ and TTX (Match % info)
  # :file     = XLZ only (Asset file info in Idiom)
  #
  #[:note] key is used for filtering
  
  @@glossaryArray = []
  #
  #each glossary data contains following keys
  # :source
  # :target
  # :option
  # :file
  #An instance of Glossary class will be generated by this array
  #It then generates instances of Glossary::Term class and keep them in Array
  
  @@monolingualArray = []
  #
  #each monolingual data contains following keys
  # :s_or_t
  # :term
  # :option
  #An instance of Monolingual class will be generated by this array
  #It then generates instances of Monolingual::Term class and keep them in Array
  
  ROWSEP = "\r\n"
  #ROWSEP = ENV["OS"] ? "\r\n" : $/
  
  #-----------------------------------
  #Methods to read bilingual & monolingual glossaries
  
  def readGloss(file)
    file_str = read_rawfile(file)
    file_str.each_line {|line|
      split_line = line.split("\t")
      entry = {}
      entry[:source] = split_line[0].chomp
      entry[:target] = split_line[1].chomp
      entry[:option] = split_line[2].chomp
      entry[:file]   = File.basename(file)
      @@glossaryArray << entry
    }
  end
  
  def readMonolingual(file)
    file_str = read_rawfile(file)
    file_str.each_line {|line|
      split_line = line.split("\t")
      entry = {}
      entry[:s_or_t] = split_line[0].chomp
      entry[:term]   = split_line[1].chomp
      entry[:option] = split_line[2].chomp
      #entry[:file]   = File.basename(file)
      @@monolingualArray << entry
    }
  end
  #------------------------------------
  
  
  #------------------------------------
  #Methods to read bilingual target files
  #
  
  #For XLZ (Idiom) file
  def readXLZ(file, option)
    buf = ""
    Zip::ZipInputStream.open(file) {|zis|
      entry = zis.get_next_entry
      next if File.extname(entry.name) != ".xlf"
      buf = zis.read
    }
    tf = Tempfile.new("buf")
    tf.print buf
    tf.close
    
    str_xslted = %x(./reader/xml tr ./reader/xlf2tsv.xsl #{tf.path})
    tf.close!
    str_xslted = Kconv.kconv(str_xslted, Kconv::UTF8, guess_encode(str_xslted))
    
    ops = {:col_sep => "\t", :quote_char => '"', :headers => true}
    myCSV = CSV.new(str_xslted, ops)
    myCSV.each {|row|
      if option[:filter] != nil
        next if row["Note"] != option[:filter]
      end
      entry = {}
      entry[:filename] = file.to_s
      entry[:source]   = row["Source"]
      entry[:target]   = row["Target"]
      entry[:id]       = row["SID"]
      entry[:note]     = row["Note"]
      entry[:file]     = row["File"]
      @@bilingualArray.push(entry)
    }
  end
  
  #For simple tab separated values. Like copy & pasted from Excel sheet
  def readTXT(file, option)
    file_str = read_rawfile(file)
    file_str.lines.each_with_index {|line, i|
      entry = {}
      entry[:filename] = file.to_s
      ch_line = line.chomp.split("\t")
      entry[:source]   = ch_line[0]
      entry[:target]   = ch_line[1]
      if ch_line[2] != (nil && "")
        entry[:id]       = ch_line[2]
      else
        entry[:id]       = "Line: #{i + 1}"
      end
      @@bilingualArray.push(entry)
    }
  end
  
  #For LocStudio CSV generated by CSVDumpW
  def readCSV(file, option)
    file_str = read_rawfile(file)
    ops = {:col_sep => ",", :headers => true, :quote_char => '"'}
    myCSV = CSV.new(file_str, ops)
    myCSV.map {|row|
      entry = {}
      entry[:filename] = file.to_s
      entry[:source]   = row["Source Term"]
      entry[:target]   = row["Translation"]
      entry[:id]       = row["Resource ID"]
      entry[:note]     = row["Term Note"]
      @@bilingualArray.push(entry)
    }
  end
  
  #For Excel sheet. Only avaliable on Windows platform
  #target is default active sheet, col A as Source, col B as Target, col C as ID
  def readXLS(file, option)
    excel = WIN32OLE.new('Excel.Application')
    file_path = getAbsolutePath(file)
    book = excel.Workbooks.Open(file_path)
    sheet = book.ActiveSheet
    
    begin
      rowNum = sheet.Range("A65536").End(:Direction  =>  -4162).Row
      
      i = 0
      rowNum.times do
        i += 1
        entry = {}
        entry[:filename] = file.to_s
        sheet.Cells(i, 1).value != nil ? entry[:source] = read_rawText(sheet.Cells(i, 1).value) : entry[:source] = ""
        sheet.Cells(i, 2).value != nil ? entry[:target] = read_rawText(sheet.Cells(i, 2).value) : entry[:target] = ""
        entry[:note]     = read_rawText(sheet.Cells(i, 3).value) if sheet.Cells(i, 3).value != nil
        entry[:id]       = "Row #{i}"
        @@bilingualArray.push(entry)
      end
    ensure
      excel.Workbooks.Close
      excel.Quit
    end
    
  end
  
  #For Trados TTX file
  def readTTX(file, option)
    file_str = read_rawfile(file)
    scannedttx = file_str.scan(/<tu .*?MatchPercent="(\d+)".*?<tuv.*?>(.*?)<\/tuv><tuv.*?>(.*?)<\/tuv><\/tu>/i)
    scannedttx.map {|tu|
      if option[:ignore_100] == true
        next if tu[0] == "100"
      end
      entry = {}
      entry[:filename] = file.to_s
      entry[:source]   = tu[1]
      entry[:target]   = tu[2]
      entry[:note]     = tu[0] #this represents match percent
      @@bilingualArray.push(entry)
    }
  end
  
  #For TMX
  def readTMX(file, option)
    file_str = read_rawfile(file)
    @doc = Nokogiri::XML(file_str)
    tus = @doc.xpath("//tu")
    tus.each{ |tu|
      tuvs = tu.xpath('./tuv')
      entry = {}
      entry[:filename] = file.to_s
      entry[:source] = tuvs[0].at("./seg").inner_text
      entry[:target] = tuvs[1].at("./seg").inner_text
      @@bilingualArray.push(entry)
    }
  end
  
private
  #Read file and return it in UTF8 format
  def read_rawfile(file)
    fl = File.open(file, "rb")
    file_str = fl.read; fl.close
    file_str = Kconv.kconv(file_str, Kconv::UTF8, guess_encode(file_str))
    #file_str = file_str.delete("\xEF\xBB\xBF")
  end
  
  #Guess file encode
  def guess_encode(str)
    encode = NKF.guess(str)
    
    #Assume all dummy encodes as UTF16
    #dummies can be UTF_16, UTF_7 & UTF_32. UTF_7 & UTF_32 are ignored as they are hardly used
    #UTF16 dummy is UTF16 with BOM
    
    encode = NKF::UTF16 if encode.dummy?
    codes = {
           NKF::UTF8    => Kconv::UTF8,
           NKF::UTF16   => Kconv::UTF16,
           NKF::SJIS    => Kconv::SJIS,
           NKF::JIS     => Kconv::JIS,
           NKF::EUC     => Kconv::EUC,
           NKF::ASCII   => Kconv::ASCII,
           NKF::BINARY  => Kconv::BINARY,
           NKF::UNKNOWN => Kconv::UNKNOWN
    }
    return codes[encode]
  end
  
  def read_rawText(str)
    Kconv.kconv(str, Kconv::UTF8, guess_encode(str))
  end
end
