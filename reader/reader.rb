#coding: utf-8

module Reader
  require 'kconv'
  require 'csv'
  require 'nkf'
  
  @@bilingualArray = []
  #
  #each bilingual data contains following keys
  # :filename = all
  # :source   = all
  # :target   = all
  # :id       = TXT and CSV, TSV (Line number)
  # :note     = TXT and TTX (Match % info)
  # :file     = TXT only (Internal file info in Idiom)
  #
  #*note key is used for filtering
  
  @@glossaryArray = []
  #
  #each glossary data contains following keys
  # :source
  # :target
  # :option
  #An instance of Glossary class will be generated by this array
  #It then generates instances of Glossary::Term class and keep them in Array
  
  ROWSEP = "\r\n"
  #ROWSEP = ENV["OS"] ? "\r\n" : $/
  
  def readGloss(file)
    file_str = read_rawfile(file)
    file_str.each_line {|line|
      split_line = line.split("\t")
      entry = {}
      entry[:source] = split_line[0].chomp
      entry[:target] = split_line[1].chomp
      entry[:option] = split_line[2].chomp if split_line[2] != nil
      @@glossaryArray << entry
    }
  end
  
  #this is for Idiom dumped txt
  def readTXT(file, option)
    file_str = read_rawfile(file)
    ops = {:col_sep => "\t", :quote_char => '"', :headers => true, :row_sep => ROWSEP}
    myCSV = CSV.new(file_str, ops)
    myCSV.each {|row|
      if option[:filter] != nil
        next if row["Note"] != option[:filter]
      end
      entry = {}
      entry[:filename] = file.to_s
      entry[:source]   = row["Source"]
      entry[:target]   = row["Target"]
      entry[:id]       = row["SID"]
      entry[:note]     = row["Note"]
      entry[:file]     = row["File"]
      @@bilingualArray.push(entry)
    }
  end
  
  #this is for simple CSV
  def readCSV(file, option)
    file_str = read_rawfile(file)
    ops = {:col_sep => ",", :quote_char => '"', :headers => true, :row_sep => ROWSEP}
    myCSV = CSV.new(file_str, ops)
    myCSV.each_with_index {|row, i|
      entry = {}
      entry[:filename] = file.to_s
      entry[:source]   = row["Source"]
      entry[:target]   = row["Target"]
      entry[:id]       = "Line: #{i + 1}"
      @@bilingualArray.push(entry)
    }
  end
  
  #this is for simple tab separated values
  def readTSV(file, option)
    file_str = read_rawfile(file)
    ops = {:col_sep => "\t", :headers => false, :row_sep => ROWSEP}
    myCSV = CSV.new(file_str, ops)
    myCSV.each_with_index {|row, i|
      entry = {}
      entry[:filename] = file.to_s
      entry[:source]   = row[0]
      entry[:target]   = row[1]
      entry[:id]       = "Line: #{i + 1}"
      @@bilingualArray.push(entry)
    }
  end
  
  #this is for Trados TTX file
  def readTTX(file, option)
    file_str = read_rawfile(file)
    scannedttx = file_str.scan(/<tu .*?MatchPercent="(\d+)".*?<tuv.*?>(.*?)<\/tuv><tuv.*?>(.*?)<\/tuv><\/tu>/i)
    scannedttx.map {|tu|
      if option[:ignore_100] == true
        next if tu[0] == "100"
      end
      entry = {}
      entry[:filename] = file.to_s
      entry[:source]   = tu[1]
      entry[:target]   = tu[2]
      entry[:note]     = tu[0] #this represents match percent
      @@bilingualArray.push(entry)
    }
  end
  
private
  #Read file and return it in UTF8 format
  def read_rawfile(file)
    fl = File.open(file, "rb")
    file_str = fl.read; fl.close
    file_str = Kconv.kconv(file_str, Kconv::UTF8, guess_encode(file_str))
    #file_str = file_str.delete("\xEF\xBB\xBF")
  end
  
  #Guess file encode
  def guess_encode(str)
    encode = NKF.guess(str)
    
    #Assume all dummy encodes as UTF16
    #dummies can be UTF_16, UTF_7 & UTF_32. UTF_7 & UTF_32 are ignored as they are hardly used
    #UTF16 dummy is UTF16 with BOM
    
    encode = NKF::UTF16 if encode.dummy?
    codes = {
           NKF::UTF8    => Kconv::UTF8,
           NKF::UTF16   => Kconv::UTF16,
           NKF::SJIS    => Kconv::SJIS,
           NKF::JIS     => Kconv::JIS,
           NKF::EUC     => Kconv::EUC,
           NKF::ASCII   => Kconv::ASCII,
           NKF::BINARY  => Kconv::BINARY,
           NKF::UNKNOWN => Kconv::UNKNOWN
    }
    return codes[encode]
  end
end

